# MySQL

## InnoDB のインデックス

InnoDB のインデックスは B+Tree と呼ばれるデータ構造です。B+Tree は B-Tree と違い、ブランチはリーフノードへのポインタを持ち、データへのポインタはリーフノードのみが持っています。  
InnoDB のインデックスには、クラスタインデックスとセカンダリインデックスがあります。

### クラスタインデックス(Clustered Index)

リーフノードに主キーと行データを格納するインデックスです。そのため、主キーを参照すると同時に行データも取得できるため非常に高速です。  
以下のような構造のテーブルがあったとします。

```
mysql> CREATE TABLE user (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, age INT NOT NULL);
Query OK, 0 rows affected (0.14 sec)

mysql> desc user;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
| age   | int(11)      | NO   |     | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.02 sec)
```

主キーの `id` を参照すると、`name`, `age` のデータも同時に取得できます。

クラスタインデックスの構造を図にすると以下のようなイメージです。

![クラスタインデックス](imgs/clustered_index.jpg)

### セカンダリインデックス(Secondary Index)

InnoDB では、クラスタインデックス以外のインデックスはすべてセカンダリインデックスです。セカンダリインデックスは、リーフノードにセカンダリインデックスの値とクラスタインデックスのキー(主キー)を格納しています。  
以下のような構造のテーブルがあったとします。

```
mysql> CREATE TABLE user (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255) NOT NULL, skey INT, INDEX (skey));
Query OK, 0 rows affected (0.04 sec)

mysql> desc user;
+-------+--------------+------+-----+---------+----------------+
| Field | Type         | Null | Key | Default | Extra          |
+-------+--------------+------+-----+---------+----------------+
| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
| name  | varchar(255) | NO   |     | NULL    |                |
| skey  | int(11)      | YES  | MUL | NULL    |                |
+-------+--------------+------+-----+---------+----------------+
3 rows in set (0.01 sec)

mysql> SHOW INDEXES FROM user;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| user  |          0 | PRIMARY  |            1 | id          | A         |           0 |     NULL | NULL   |      | BTREE      |         |               |
| user  |          1 | skey     |            1 | skey        | A         |           0 |     NULL | NULL   | YES  | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
2 rows in set (0.00 sec)
```

セカンダリインデックスの構造を図にすると以下のようなイメージです。

![セカンダリインデックス](imgs/secondary_index.jpg)

セカンダリインデックス `skey` を参照すると主キーである `id` を特定できます。主キーが特定できたらクラスタインデックスを参照して行データを取得します。このようにセカンダリインデックスでは、主キーの特定と行データの取得の2回インデックスを探索する必要があります。そのため、クラスタインデックスと比較すると低速です。

#### プライマリキーを使った参照

```
mysql> SELECT * FROM t1 WHERE id = 500000;
+--------+--------+----------+-----------+
| id     | c1     | c2       | c3        |
+--------+--------+----------+-----------+
| 500000 | 500000 | 10500000 | 100500000 |
+--------+--------+----------+-----------+
1 row in set (0.00 sec)

mysql> EXPLAIN SELECT * FROM t1 WHERE id = 500000;
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | t1    | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |
+----+-------------+-------+-------+---------------+---------+---------+-------+------+-------+
1 row in set (0.00 sec)
```

#### インデックスを使わない参照

```
mysql> SELECT * FROM t1 WHERE c1 = 500000;
+--------+--------+----------+
| id     | c1     | c2       |
+--------+--------+----------+
| 500000 | 500000 | 10500000 |
+--------+--------+----------+
1 row in set (0.17 sec)

mysql> EXPLAIN SELECT * FROM t1 WHERE c1 = 500000;
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | t1    | ALL  | NULL          | NULL | NULL    | NULL | 998222 | Using where |
+----+-------------+-------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.00 sec)
```

#### インデックスを使った参照

```shell
mysql -u root testdb -e "ALTER TABLE t1 ADD INDEX c1(c1)"
```

```
mysql> SELECT * FROM t1 WHERE c1 = 500000;
+--------+--------+----------+-----------+
| id     | c1     | c2       | c3        |
+--------+--------+----------+-----------+
| 500000 | 500000 | 10500000 | 100500000 |
+--------+--------+----------+-----------+
1 row in set (0.00 sec)

mysql> EXPLAIN SELECT * FROM t1 WHERE c1 = 500000;
+----+-------------+-------+------+---------------+------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key  | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------+
|  1 | SIMPLE      | t1    | ref  | c1            | c1   | 5       | const |    1 | NULL  |
+----+-------------+-------+------+---------------+------+---------+-------+------+-------+
1 row in set (0.00 sec)

```

#### 複合インデックスを使った参照

```shell
mysql -u root testdb -e "ALTER TABLE t1 ADD INDEX c1_c2(c1, c2)"
mysql -u root testdb -e "ALTER TABLE t1 DROP INDEX c1"
```

```
mysql> SELECT * FROM t1 WHERE c1 = 500000 AND c2 = 10500000;
+--------+--------+----------+-----------+
| id     | c1     | c2       | c3        |
+--------+--------+----------+-----------+
| 500000 | 500000 | 10500000 | 100500000 |
+--------+--------+----------+-----------+
1 row in set (0.00 sec)

mysql> EXPLAIN SELECT * FROM t1 WHERE c1 = 500000 AND c2 = 10500000;
+----+-------------+-------+------+---------------+-------+---------+-------------+------+-------+
| id | select_type | table | type | possible_keys | key   | key_len | ref         | rows | Extra |
+----+-------------+-------+------+---------------+-------+---------+-------------+------+-------+
|  1 | SIMPLE      | t1    | ref  | c1_c2         | c1_c2 | 10      | const,const |    1 | NULL  |
+----+-------------+-------+------+---------------+-------+---------+-------------+------+-------+
1 row in set (0.00 sec)
```

```
mysql> SELECT * FROM t1 WHERE c1 = 500000;
+--------+--------+----------+-----------+
| id     | c1     | c2       | c3        |
+--------+--------+----------+-----------+
| 500000 | 500000 | 10500000 | 100500000 |
+--------+--------+----------+-----------+
1 row in set (0.00 sec)

mysql> EXPLAIN SELECT * FROM t1 WHERE c1 = 500000;
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------+
| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows | Extra |
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------+
|  1 | SIMPLE      | t1    | ref  | c1_c2         | c1_c2 | 5       | const |    1 | NULL  |
+----+-------------+-------+------+---------------+-------+---------+-------+------+-------+
1 row in set (0.00 sec)
```

#### カバリングインデックスを使った参照

カバリングインデックスは、WHERE の条件と参照するカラムが INDEX に含まれているカラムのみだった場合に利用されます。以下のようなインデックスを作成し、

```shell
mysql -u root testdb -e "ALTER TABLE t1 ADD INDEX c1_c2_c3(c1, c2, c3)"
mysql -u root testdb -e "ALTER TABLE t1 DROP INDEX c1_c2"
```

以下のようなクエリを実行するとカバリングインデックスを使った参照になります。

```
mysql> SELECT c2, c3 FROM t1 WHERE c1 = 500000;
+----------+-----------+
| c2       | c3        |
+----------+-----------+
| 10500000 | 100500000 |
+----------+-----------+
1 row in set (0.00 sec)

mysql> EXPLAIN SELECT c2, c3 FROM t1 WHERE c1 = 500000;
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
| id | select_type | table | type | possible_keys | key      | key_len | ref   | rows | Extra       |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
|  1 | SIMPLE      | t1    | ref  | c1_c2_c3      | c1_c2_c3 | 5       | const |    1 | Using index |
+----+-------------+-------+------+---------------+----------+---------+-------+------+-------------+
1 row in set (0.00 sec)
```

EXPLAIN の実行結果 の Extra が `Using index` となっていますね。これは、セカンダリインデックスのみを参照することですべてのデータを取得できていることを示しています。
インデックスが `c1_c2(c1, c2)` だった場合、c3 の値を取得するにはインデックスを参照して主キーを特定し、その主キーでデータを検索して c3 カラムの値を取得する、という動作になります。
